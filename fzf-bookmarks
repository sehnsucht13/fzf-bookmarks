#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#     Copyright (C) 2019 Yavor Konstantinov
#

#! /usr/bin/bash

# Holds the selected bookmark
selectedBookmark=""

# holds the path to the bookmark file
bookmarkPath="$HOME/.config/fzf-bookmarks/bookmarks"

# Path to the program config used to launch files
fileLauncherPath="$HOME/.config/fzf-bookmarks/config"

# check if fzf is installed
if   ! type "fzf" > /dev/null; then
		echo "fzf is not installed! Please install it before using this program"
		exit 1
fi

# check if the bookmark file exists
# if it does not, it will be created in the .config folder
function checkBookmarkDirectory(){
	if [ ! -d "$HOME/.config/fzf-bookmarks" ]
	then
			cd "$HOME/.config"
			mkdir "fzf-bookmarks"
			cd "fzf-bookmarks"
			touch "bookmarks"
			touch "config"
			echo "DEFAULT $EDITOR" >> config
	fi
}

# Open a file with the selected program in the config file or $EDITOR otherwise
open_file(){
	# Check if the bookmark is not empty. If it is, do nothing
	if [ ! -z $selectedBookmark ]
	then
		# Retrieve the file type
		local fileType=$(awk -v var=$selectedBookmark '$1 == var {print $4}' $bookmarkPath)
		local fileLocation=$(awk -v var=$selectedBookmark '$1 == var {print $3}' $bookmarkPath)
		# Retrieve the corresponding program used to launch
		local program=$(awk -v var=$fileType '$1 == var {print $2}' $fileLauncherPath)
		# Launch the program in a detached state
		# Currently does not work if $EDITOR is a terminal one
		if [ ! -z $program ]
		then
			# Retrieve the value of $EDITOR to see if it is a terminal based one
			program=$(eval echo $program)

			# Check for some common terminal editors
			if [ $program = "vim" ] || [ $program = "vi" ] || \
			[ $program = "nano" ] || [ $program = "ed" ] || \
			[ $program = "emacs -nw" ] || [ $program = "emacsclient -nw" ]
			then
				eval "$program" $fileLocation
			else
				# start program/editor in background to not block terminal 
				eval "$program" $fileLocation &
			fi
				
		# Deal with the case of a filetype not existing
		else
			program=$(awk -v var="DEFAULT" '$1 == var {print $2}' $fileLauncherPath)
			eval "$program" $fileLocation
		fi
	fi
}

# Open a directory
open_dir(){
	if [ ! -z $selectedBookmark ]
	then 
		cd $(awk -v var="$selectedBookmark" '$1 == var {print $3}' $bookmarkPath)
	fi
}

# Change directories to the selected bookmark
# This function uses a flag to decide if the bookmarks should be filtered or not.
# The accepted flag values are:
# 0: Show all bookmarks(unfiltered)
# 1: Show only directory bookmarks
# 2: Show only files
function switchToBookmark(){
	# Check if there are any bookmarks.
	local bmarkLineNum=$(wc -l $bookmarkPath | awk '{print $1}')
	if [ $bmarkLineNum == 0 ]
	then
		printf "You do not have any bookmarks set\n"
		printf "You can add some by calling \"fzf-bookmarks -a NAME PATH\"\n"

	# Show all bookmarks without filtering
	elif [ $1 -eq 0 ]
	then
			selectedBookmark=$(awk '{print $1, $2}' $bookmarkPath | fzf)
			# Grab the type of selected bookmark(either DIR or FILE)
			local type=$(echo $selectedBookmark | awk '{print $2}')
			selectedBookmark=$(echo $selectedBookmark | awk '{print $1}') 
			if [ $type == "DIR" ]
			then
				open_dir
			elif [ $type == "FILE" ]
			then
				open_file
			fi

	# Case of selecting only directories
	elif [ $1 -eq 1 ]
	then
		selectedBookmark=$(awk ' $2 == "DIR" {print $1}' $bookmarkPath | fzf)
		open_dir

	# Case of selecting only files
	else [ $1 -eq 2 ]
		selectedBookmark=$(awk ' $2 == "FILE" {print $1}' $bookmarkPath | fzf)
		open_file
	fi
}

# Add a new bookmark
# If a path is not provided then the current directory is used
function addBookmark(){
	# check if a bookmark with the name provided already exists
	local boolUnique=$(awk -v var="$1" '$1 == var {print 1}' $bookmarkPath)
	if [ ! -z "$boolUnique" ]
	then
		printf "A bookmark with that name already exists! Please enter a different one.\n"
	

	# If the second argument passed is empty
	elif [ -z "$2" ] 
	then
		printf "$1\tDIR\t$PWD\n" >> $bookmarkPath
		printf "Bookmark added successfully!\n"
	# Case of a path being provided 
	elif [ -d $2 ]
	then
		if [[ $2 = /* ]]
		then
			printf "$1\tDIR\t$2\n"  >> $bookmarkPath
		else
			printf "$1\tDIR\t%s\n" $(echo "$PWD""/"$2) >> $bookmarkPath
		fi
	# Case of adding a file
	elif [ -e $2 ]
	then
		# retrieve the file extension
		# Source: https://liquidat.wordpress.com/2007/09/29/short-tip-get-file-extension-in-shell-script/
		local extension=$( echo "$*" | awk -F . '{print $NF}')

		# Check if the full filepath is provided. If not, we have to prepend the full path to be able to access
		# the bookmark from anywhere
		if [[ $2 = /* ]]
		then
			printf "$1\tFILE\t$2\t$extension\n"  >> $bookmarkPath
		else
			printf "$1\tFILE\t%s\t$extension\n" $(echo "$PWD""/"$2) >> $bookmarkPath
		fi

	# Incomplete bookmark.
	else
		printf "The path provided is neither a folder or a file! It most likely does not exist!\n"
	fi
}

# Erase the entire bookmark file and create a fresh one
function eraseAllBookmarks(){
	rm $bookmarkPath
	touch $bookmarkPath
}

# Display all aliases to the user and let them select one
function selectAlias(){
	local selectedAlias=$(awk '/^alias (.*)=/ {print $0}' "$HOME/.bashrc" | fzf)

	# Split the string by using = as a delimiter
	# Remove the quotes surrounding it
	# print and set new variable
	selectedAlias=$(echo "$selectedAlias" | awk '{split($0, a, "="); gsub("\047", "", a[2]); print a[2]}')
	eval "$selectedAlias"
}

function selectManPage(){
	# hold the name of selected page 
	local selectedPage=""

	# Print all manpage sections
	if [ -z $1 ]
	then
		# variable to hold the selected manpage
		selectedPage=$(man -k . | awk '{print $1 $2}' | fzf)
		exec man $selectedPage

	# Exec manpages for selected section
	else
		selectedPage=$(apropos -s "$1" . | awk '{print $1}'| fzf)
		exec man $selectedPage
	fi
}

# Remove the specified bookmark from the bookmarks file
function removeBookmark(){
	if [ ! -z "$2" ]
	then
		printf "Too many arguments. Either provide the name of a bookmark or do not provide any arguments to select the bookmark through fzf\n"
	# case of no arg provided, use fzf to select
	elif [ -z "$1" ]
	then
			selectedBookmark=$(awk '{print $1}' $bookmarkPath | fzf)
			# Handle the case of the user pressing CTRL+C
			# if we do not check that $selectedBookmark is not empty
			# then the entire list of bookmarks is deleted
			if [ ! -z $selectedBookmark ]
			then
				# remove the selected bookmark
				sed -i "/^${selectedBookmark}\s.*/d" "$bookmarkPath"
			fi

	# case of providing a name manually
	else 
		local selectedBookmarkIndex=$(awk -v var="$1" '$1 == var {print NR}' $bookmarkPath)
		if [ ! -z $selectedBookmarkIndex ]
		then
				# Delete the bookmark
				sed -i "${selectedBookmarkIndex}d" "$bookmarkPath"
		else
				printf "Bookmark not found! It most likely does not exist\n"
		fi
	fi
}

checkBookmarkDirectory
# Parse script arguments
if [ -z $1 ]
then 
	# Display all bookmarks
	switchToBookmark 0

elif [ $1 == "-d" ] || [ $1 == "--dir" ]
then
	# Display directories only
	switchToBookmark 1

elif [ $1 == "-f" ] || [ $1 == "--file" ]
then
	# Display Files only
	switchToBookmark 2

elif [ $1 == "-a" ] || [ $1 == "--add" ]
then
	# Add a new bookmark
	addBookmark "$2" "$3"

elif [ $1 == "-r" ] || [ $1 == "--remove" ]
then
	# Remove a bookmark
	removeBookmark "$2" "$3"	

elif [ $1 == "--eraseall" ]
then
	# Erase all bookmarks and create a new blank file
	eraseAllBookmarks

elif [ $1 == "-al" ] || [ $1 == "--alias" ]
then
	# Select an alias and execute it
	selectAlias	

elif [ $1 == "-m" ] || [ $1 == "--man" ]
then
	# Fuzzy search through man pages(Not working fully)
	selectManPage $2
	
# Print usage
elif [ $1 == "--usage" ] 
then
	printf "fzf-bookmarks is a small bookmark manager for the commandline with the ability to bookmark\n"
	printf "both directories and files. Additionally, when a bookmark is selected, it will be open either\n"
	printf "with a dedicated program selected from the config file located in ~/.config/fzf-bookmarks/config\n"
	printf "or in the case of a folder, navigate to it in the current terminal instance.\n"

# Use -- infront of printf to make it ignore -d, -f, -a and so on. 
# Otherwise, it considers them to be options
elif [ $1 == "-h" ] || [ $1 == "--help" ]
then
	printf "Usage: fzf-bookmarks [options] [argument1] [argument2]\n\n"
	printf "Options:\n"
	printf -- "-d, --dir	Select a bookmarked directory\n"
	printf -- "-f, --file	Select a bookmarked file\n"
	printf -- "-a, --add	Add a file or directory to bookmarks\n"
	printf -- "-r, --remove	Delete a bookmark\n"
	printf -- "--eraseall	Erase the entire bookmark file and replace it with a new one\n"
	printf -- "-al, --alias	Select an alias from your .bashrc file\n"
	printf -- "-m, --man	Select a manpage to open\n"
	printf -- "--usage		Show a short usage message\n"
	printf -- "-h, --help	Display help menu and options\n"
fi
