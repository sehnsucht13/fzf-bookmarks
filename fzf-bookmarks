#! /usr/bin/bash

# find file extension for a file
#  echo "thisfile.txt"|awk -F . '{print $NF}'

# Holds the selected bookmark
selectedBookmark=""

# holds the path to the bookmark file
bookmarkPath="$HOME/.config/fzf-bookmarks/bookmarks"

# Path to the program config used to launch files
fileLauncherPath="$HOME/.config/fzf-bookmarks/config"

# check if fzf is installed
if   ! type "fzf" > /dev/null; then
		echo "fzf is not installed! Please install it before using this program"
		exit 1
fi

# check if the bookmark file exists
# if it does not, it will be created in the .config folder
function checkBookmarkDirectory(){
	if [ ! -d "$HOME/.config/fzf-bookmarks" ]
	then
			cd "$HOME/.config"
			mkdir "fzf-bookmarks"
			cd "fzf-bookmarks"
			touch "bookmarks"
			touch "config"
	fi
}
# Open a file with the selected program in the config file or $EDITOR otherwise
open_file(){
	selectedBookmark=$(awk ' $2 == "FILE" {print $1}' $bookmarkPath | fzf)
	# Retrieve the file type
	local fileType=$(awk -v var=$selectedBookmark '$1 == var {print $4}' $bookmarkPath)
	local fileLocation=$(awk -v var=$selectedBookmark '$1 == var {print $3}' $bookmarkPath)
	# Retrieve the corresponding program used to launch
	local program=$(awk -v var=$fileType '$1 == var {print $2}' $fileLauncherPath)
	# Launch the program in a detached state
	# Currently does not work if $EDITOR is a terminal one
	if [ ! -z $program ]
	then
		echo $program
		if [ $program = "$EDITOR" ]
		then
			echo "Got editor"
		fi

		if [ $program = "vim" ] || [ $program = "vi" ] || [ $program = "nano" ]
		then
			echo "Got a vim/vi/nano"
			eval "$program" $fileLocation
		else
			eval "$program" $fileLocation 
		fi
			
	else
		program=$(awk -v var="DEFAULT" '$1 == var {print $2}' $fileLauncherPath)
		echo "Got a nonstandart"
		echo $program
		eval "$program" $fileLocation
	fi
}

# Open a directory
open_dir(){
	selectedBookmark=$(awk ' $2 == "DIR" {print $1}' $bookmarkPath | fzf)
	echo $selectedBookmark
	if [ ! -z $selectedBookmark ]
	then 
		cd $(awk -v var="$selectedBookmark" '$1 == var {print $3}' $bookmarkPath)
		fi
}

# Change directories to the selected bookmark
# This function uses a flag to decide if the bookmarks should be filtered or not.
# The accepted flag values are:
# 0: Show all bookmarks(unfiltered)
# 1: Show only directory bookmarks
# 2: Show only files
function switchToBookmark(){
	# Check if there are any bookmarks.
	local bmarkLineNum=$(wc -l $bookmarkPath | awk '{print $1}')
	if [ $bmarkLineNum == 0 ]
	then
		printf "You do not have any bookmarks set\n"
		exit 1
	fi

	# Show all bookmarks without filtering
	if [ $1 -eq 0 ]
	then
			selectedBookmark=$(awk '{print $1, $2}' $bookmarkPath | fzf)
			# Grab the type of selected bookmark(either DIR or FILE)
			local type=$(echo $selectedBookmark | awk '{print $2}')
			selectedBookmark=$(echo $selectedBookmark | awk '{print $1}') 
			if [ $type == "DIR" ]
			then
				open_dir
			else
				open_file
			fi

	# Case of a only directories
	elif [ $1 -eq 1 ]
	then
		open_dir

	# Case of listing only files
	else [ $1 -eq 2 ]
		 open_file
	fi
}

# Add a new bookmark
# If a path is not provided then the current directory is used
function addBookmark(){
	# check if a bookmark with the name provided already exists
	local boolUnique=$(awk -v var="$1" '$1 == var {print 1}' $bookmarkPath)
	if [ "$boolUnique" == "1" ]
	then
		printf "A bookmark with that name already exists! Please enter a different one.\n"
		exit 1
	fi

	# If the second argument passed is empty
	if [ -z "$2" ] 
	then
		printf "$1\tDIR\t$PWD\n" >> $bookmarkPath
		printf "Bookmark added successfully!\n"
	# Case of a path being provided 
	elif [ -d $2 ]
	then
		printf "$1\tDIR\t$2\n" >> $bookmarkPath
		printf "Bookmark added successfully!\n"
	# Case of adding a file
	elif [ -e $2 ]
	then
		# retrieve the file extension
		# Source: https://liquidat.wordpress.com/2007/09/29/short-tip-get-file-extension-in-shell-script/
		local extension=$( echo "$*" | awk -F . '{print $NF}')
		printf "$1\tFILE\t$2\t$extension\n" >> $bookmarkPath
		printf "Bookmark added successfully!\n"
	# Incomplete bookmark.
	else
		printf "The path provided is neither a folder or a file! It most likely does not exist!\n"
	fi
}

# Erase the entire bookmark file and create a fresh one
function eraseAllBookmarks(){
	rm $bookmarkPath
	touch $bookmarkPath
}

# Display all aliases to the user and let them select one
function selectAlias(){
	local selectedAlias=$(awk '/^alias / {print $0}' "$HOME/.bashrc" | fzf)
}

function selectManPage(){
	# hold the name of selected page 
	local selectedPage=""

	# Print all manpage sections
	if [ -z $1 ]
	then
		# variable to hold the selected manpage
		selectedPage=$(man -k . | awk '{print $1 $2}' | fzf)
		exec man $selectedPage

	# Exec manpages for selected section
	else
		selectedPage=$(apropos -s "$1" . | awk '{print $1}'| fzf)
		exec man $selectedPage
	fi
}
# Remove the specified bookmark from the bookmarks file
function removeBookmark(){
	if [ ! -z "$2" ]
	then
		printf "Too many arguments. Either provide the name of a bookmark or do not provide anything to delete through fzf\n"
	# case of no arg provided, use fzf to select
	elif [ -z "$1" ]
	then
			selectedBookmark=$(awk '{print $1}' $bookmarkPath | fzf)
			# Handle the case of the user pressing CTRL+C
			# if we do not check that $selectedBookmark is not empty
			# then the entire list of bookmarks is deleted
			if [ ! -z $selectedBookmark ]
			then
				# remove the selected bookmark
				# using sed instead of awk since we do not 
				# have to copy the entire file over
				sed -i "/^$selectedBookmark/d" $bookmarkPath
			fi
			exit 0
	# case of providing a name manually
	else 
		local selectedBookmarkIndex=$(awk -v var="$1" '$1 == var {print NR}' $bookmarkPath)
		if [ ! -z $selectedBookmarkIndex ]
		then
				# delete the line number 
				sed -i "$selectedBookmarkIndex"d "$bookmarkPath"
		else
				printf "Bookmark not found!\n"
		fi
	fi
}

checkBookmarkDirectory
# Parse script arguments
if [ -z $1 ]
then 
	# Display all bookmarks
	switchToBookmark 0

elif [ $1 == "-d" ]
then
	# Display directories only
	switchToBookmark 1

elif [ $1 == "-f" ]
then
	# Display Files only
	switchToBookmark 2

elif [ $1 == "-a" ]
then
	addBookmark "$2" "$3"

elif [ $1 == "-r" ]
then

	removeBookmark "$2" "$3"	
elif [ $1 == "-eraseall" ]
then

	eraseAllBookmarks
elif [ $1 == "-al" ]
then

	selectAlias	
elif [ $1 == "-m" ]
then

	selectManPage $2
fi
